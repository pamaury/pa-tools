/*
 * linux/include/asm-mips/mach-jz4760b/jz4760bmsc.h
 *
 * JZ4760B MSC register definition.
 *
 * Copyright (C) 2010 Ingenic Semiconductor Co., Ltd.
 */

// 
// #ifndef __JZ4760BMSC_H__
// #define __JZ4760BMSC_H__

// 
const JZ_MAX_MSC_NUM 3

// 
// #define JZ_MSC_ID_INVALID(msc_id) ( ((msc_id) < 0) || ( (msc_id) > JZ_MAX_MSC_NUM ) )

// 
this class MSC goto (0, 0xB0021000)
this class MSC goto (1, 0xB0022000)
this class MSC goto (2, 0xB0023000)

// 
for n 0 2
register STRPCL goto<n> "(n)*0x1000 + 0x000" export ""
register STAT goto<n> "(n)*0x1000 + 0x004" export ""
register CLKRT goto<n> "(n)*0x1000 + 0x008" export ""
register CMDAT goto<n> "(n)*0x1000 + 0x00C" export ""
register RESTO goto<n> "(n)*0x1000 + 0x010" export ""
register RDTO goto<n> "(n)*0x1000 + 0x014" export ""
register BLKLEN goto<n> "(n)*0x1000 + 0x018" export ""
register NOB goto<n> "(n)*0x1000 + 0x01C" export ""
register SNOB goto<n> "(n)*0x1000 + 0x020" export ""
register IMASK goto<n> "(n)*0x1000 + 0x024" export ""
register IREG goto<n> "(n)*0x1000 + 0x028" export ""
register CMD goto<n> "(n)*0x1000 + 0x02C" export ""
register ARG goto<n> "(n)*0x1000 + 0x030" export ""
register RES goto<n> "(n)*0x1000 + 0x034" export ""
register RXFIFO goto<n> "(n)*0x1000 + 0x038" export ""
register TXFIFO goto<n> "(n)*0x1000 + 0x03C" export ""
register LPM goto<n> "(n)*0x1000 + 0x040" export ""

// 
register STRPCL sizeof 16
register STAT sizeof 32
register CLKRT sizeof 16
register CMDAT sizeof 32
register RESTO sizeof 16
register RDTO sizeof 32
register BLKLEN sizeof 16
register NOB sizeof 16
register SNOB sizeof 16
register IMASK sizeof 32
register IREG sizeof 16
register CMD sizeof 8
register ARG sizeof 32
register RES sizeof 16
register RXFIFO sizeof 32
register TXFIFO sizeof 32
register LPM sizeof 32

// 
register STRPCL export "MSC Clock and Control Register"
register STRPCL int SEND_CCSD goto 15 export "send command completion signal disable to ceata"
register STRPCL int SEND_AS_CCSD goto 14 export "send internally generated stop after sending ccsd"
register STRPCL int EXIT_MULTIPLE goto 7
register STRPCL int EXIT_TRANSFER goto 6
register STRPCL int START_READWAIT goto 5
register STRPCL int STOP_READWAIT goto 4
register STRPCL int RESET goto 3
register STRPCL int START_OP goto 2
const MSC_STRPCL_CLOCK_CONTROL_BIT 0
register STRPCL int CLOCK_CONTROL goto (0x3 << MSC_STRPCL_CLOCK_CONTROL_BIT)
register STRPCL int CLOCK_CONTROL enum STOP 0x1 export "Stop MMC/SD clock"
register STRPCL int CLOCK_CONTROL enum START 0x2 export "Start MMC/SD clock"

// 
register STAT export "MSC Status Register"
register STAT int AUTO_CMD_DONE goto 31 export "12 is internally generated by controller has finished"
register STAT int IS_RESETTING goto 15
register STAT int SDIO_INT_ACTIVE goto 14
register STAT int PRG_DONE goto 13
register STAT int DATA_TRAN_DONE goto 12
register STAT int END_CMD_RES goto 11
register STAT int DATA_FIFO_AFULL goto 10
register STAT int IS_READWAIT goto 9
register STAT int CLK_EN goto 8
register STAT int DATA_FIFO_FULL goto 7
register STAT int DATA_FIFO_EMPTY goto 6
register STAT int CRC_RES_ERR goto 5
register STAT int CRC_READ_ERROR goto 4
const MSC_STAT_CRC_WRITE_ERROR_BIT 2
register STAT int CRC_WRITE_ERROR goto (0x3 << MSC_STAT_CRC_WRITE_ERROR_BIT)
register STAT int CRC_WRITE_ERROR enum NO 0 export "No error on transmission of data"
register STAT int CRC_WRITE_ERROR enum DATA 1 export "Card observed erroneous transmission of data"
register STAT int CRC_WRITE_ERROR enum NOSTS 2 export "No CRC status is sent back"
register STAT int TIME_OUT_RES goto 1
register STAT int TIME_OUT_READ goto 0

// 
register CLKRT export "MSC Bus Clock Control Register"
const MSC_CLKRT_CLK_RATE_BIT 0
register CLKRT int CLK_RATE goto (0x7 << MSC_CLKRT_CLK_RATE_BIT)
register CLKRT int CLK_RATE enum DIV_1 0x0 export "CLK_SRC"
register CLKRT int CLK_RATE enum DIV_2 0x1 export "1/2 of CLK_SRC"
register CLKRT int CLK_RATE enum DIV_4 0x2 export "1/4 of CLK_SRC"
register CLKRT int CLK_RATE enum DIV_8 0x3 export "1/8 of CLK_SRC"
register CLKRT int CLK_RATE enum DIV_16 0x4 export "1/16 of CLK_SRC"
register CLKRT int CLK_RATE enum DIV_32 0x5 export "1/32 of CLK_SRC"
register CLKRT int CLK_RATE enum DIV_64 0x6 export "1/64 of CLK_SRC"
register CLKRT int CLK_RATE enum DIV_128 0x7 export "1/128 of CLK_SRC"

// 
register CMDAT export "MSC Command Sequence Control Register"
register CMDAT int CCS_EXPECTED goto 31 export "interrupts are enabled in ce-ata"
register CMDAT int READ_CEATA goto 30
register CMDAT int SDIO_PRDT goto 17 export "exact 2 cycle"
register CMDAT int SEND_AS_STOP goto 16
const MSC_CMDAT_RTRG_BIT 14
register CMDAT int RTRG goto (3 << MSC_CMDAT_RTRG_BIT)
register CMDAT int RTRG enum EQUALT_8 0x0
register CMDAT int RTRG enum EQUALT_16 0x1 export "reset value"
register CMDAT int RTRG enum EQUALT_24 0x2
const MSC_CMDAT_TTRG_BIT 12
register CMDAT int TTRG goto (3 << MSC_CMDAT_TTRG_BIT)
register CMDAT int TTRG enum LESS_8 0x0
register CMDAT int TTRG enum LESS_16 0x1 export "reset value"
register CMDAT int TTRG enum LESS_24 0x2
register CMDAT int STOP_ABORT goto 11
const MSC_CMDAT_BUS_WIDTH_BIT 9
register CMDAT int BUS_WIDTH goto (0x3 << MSC_CMDAT_BUS_WIDTH_BIT)
register CMDAT int BUS_WIDTH enum "1BIT" 0x0 export "1-bit data bus"
register CMDAT int BUS_WIDTH enum "4BIT" 0x2 export "4-bit data bus"
register CMDAT int BUS_WIDTH enum "8BIT" 0x3 export "8-bit data bus"
register CMDAT int DMA_EN goto 8
register CMDAT int INIT goto 7
register CMDAT int BUSY goto 6
register CMDAT int STREAM_BLOCK goto 5
register CMDAT int WRITE goto 4
// #define	MSC_CMDAT_READ			(0 << 4)
register CMDAT int DATA_EN goto 3
const MSC_CMDAT_RESPONSE_BIT 0
register CMDAT int RESPONSE goto (0x7 << MSC_CMDAT_RESPONSE_BIT)
register CMDAT int RESPONSE enum NONE 0x0 export "No response"
register CMDAT int RESPONSE enum R1 0x1 export "Format R1 and R1b"
register CMDAT int RESPONSE enum R2 0x2 export "Format R2"
register CMDAT int RESPONSE enum R3 0x3 export "Format R3"
register CMDAT int RESPONSE enum R4 0x4 export "Format R4"
register CMDAT int RESPONSE enum R5 0x5 export "Format R5"
register CMDAT int RESPONSE enum R6 0x6 export "Format R6"

// 
register IMASK export "MSC Interrupts Mask Register"
register IMASK int AUTO_CMD_DONE goto 15
register IMASK int DATA_FIFO_FULL goto 14
register IMASK int DATA_FIFO_EMP goto 13
register IMASK int CRC_RES_ERR goto 12
register IMASK int CRC_READ_ERR goto 11
register IMASK int CRC_WRITE_ERR goto 10
register IMASK int TIMEOUT_RES goto 9
register IMASK int TIMEOUT_READ goto 8
register IMASK int SDIO goto 7
register IMASK int TXFIFO_WR_REQ goto 6
register IMASK int RXFIFO_RD_REQ goto 5
register IMASK int END_CMD_RES goto 2
register IMASK int PRG_DONE goto 1
register IMASK int DATA_TRAN_DONE goto 0

// 
register IREG export "MSC Interrupts Status Register"
register IREG int AUTO_CMD_DONE goto 15
register IREG int DATA_FIFO_FULL goto 14
register IREG int DATA_FIFO_EMP goto 13
register IREG int CRC_RES_ERR goto 12
register IREG int CRC_READ_ERR goto 11
register IREG int CRC_WRITE_ERR goto 10
register IREG int TIMEOUT_RES goto 9
register IREG int TIMEOUT_READ goto 8
register IREG int SDIO goto 7
register IREG int TXFIFO_WR_REQ goto 6
register IREG int RXFIFO_RD_REQ goto 5
register IREG int END_CMD_RES goto 2
register IREG int PRG_DONE goto 1
register IREG int DATA_TRAN_DONE goto 0

// 
register LPM export "MSC Low Power Mode Register"
register LPM int LPM goto 0

// 

// 
// #ifndef __MIPS_ASSEMBLER

// 
/***************************************************************************
 * MSC
 ***************************************************************************/
/* n = 0, 1 (MSC0, MSC1) */

// 
// #define __msc_start_op(n)						\
// 	( REG_MSC_STRPCL(n) = MSC_STRPCL_START_OP | MSC_STRPCL_CLOCK_CONTROL_START )

// 
// #define __msc_set_resto(n, to)  	( REG_MSC_RESTO(n) = to )
// #define __msc_set_rdto(n, to)   	( REG_MSC_RDTO(n) = to )
// #define __msc_set_cmd(n, cmd)   	( REG_MSC_CMD(n) = cmd )
// #define __msc_set_arg(n, arg)   	( REG_MSC_ARG(n) = arg )
// #define __msc_set_nob(n, nob)      	( REG_MSC_NOB(n) = nob )
// #define __msc_get_nob(n)        	( REG_MSC_NOB(n) )
// #define __msc_set_blklen(n, len)        ( REG_MSC_BLKLEN(n) = len )
// #define __msc_set_cmdat(n, cmdat)   	( REG_MSC_CMDAT(n) = cmdat )
// #define __msc_set_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_IO_ABORT )
// #define __msc_clear_cmdat_ioabort(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_IO_ABORT )

// 
// #define __msc_set_cmdat_bus_width1(n)				\
// 	do { 							\
// 		REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
// 		REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_1BIT; 	\
// 	} while(0)

// 
// #define __msc_set_cmdat_bus_width4(n)				\
// 	do { 							\
// 		REG_MSC_CMDAT(n) &= ~MSC_CMDAT_BUS_WIDTH_MASK; 	\
// 		REG_MSC_CMDAT(n) |= MSC_CMDAT_BUS_WIDTH_4BIT; 	\
// 	} while(0)

// 
// #define __msc_set_cmdat_dma_en(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DMA_EN )
// #define __msc_set_cmdat_init(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_INIT )
// #define __msc_set_cmdat_busy(n) 	( REG_MSC_CMDAT(n) |= MSC_CMDAT_BUSY )
// #define __msc_set_cmdat_stream(n)       ( REG_MSC_CMDAT(n) |= MSC_CMDAT_STREAM_BLOCK )
// #define __msc_set_cmdat_block(n)        ( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_STREAM_BLOCK )
// #define __msc_set_cmdat_read(n) 	( REG_MSC_CMDAT(n) &= ~MSC_CMDAT_WRITE_READ )
// #define __msc_set_cmdat_write(n)        ( REG_MSC_CMDAT(n) |= MSC_CMDAT_WRITE_READ )
// #define __msc_set_cmdat_data_en(n)      ( REG_MSC_CMDAT(n) |= MSC_CMDAT_DATA_EN )

// 
/* r is MSC_CMDAT_RESPONSE_FORMAT_Rx or MSC_CMDAT_RESPONSE_FORMAT_NONE */
// #define __msc_set_cmdat_res_format(n, r)				\
// 	do { 								\
// 		REG_MSC_CMDAT(n) &= ~MSC_CMDAT_RESPONSE_FORMAT_MASK; 	\
// 		REG_MSC_CMDAT(n) |= (r);				\
// 	} while(0)

// 
// #define __msc_clear_cmdat(n)						\
// 	REG_MSC_CMDAT(n) &= ~( MSC_CMDAT_IO_ABORT | MSC_CMDAT_DMA_EN | MSC_CMDAT_INIT| \
// 			       MSC_CMDAT_BUSY | MSC_CMDAT_STREAM_BLOCK | MSC_CMDAT_WRITE_READ | \
// 			       MSC_CMDAT_DATA_EN | MSC_CMDAT_RESPONSE_FORMAT_MASK )

// 
// #define __msc_get_imask(n) 		( REG_MSC_IMASK(n) )
// #define __msc_mask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0xff )
// #define __msc_unmask_all_intrs(n) 	( REG_MSC_IMASK(n) = 0x00 )
// #define __msc_mask_rd(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_RXFIFO_RD_REQ )
// #define __msc_unmask_rd(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_RXFIFO_RD_REQ )
// #define __msc_mask_wr(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_TXFIFO_WR_REQ )
// #define __msc_unmask_wr(n) 		( REG_MSC_IMASK(n) &= ~MSC_IMASK_TXFIFO_WR_REQ )
// #define __msc_mask_endcmdres(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_END_CMD_RES )
// #define __msc_unmask_endcmdres(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_END_CMD_RES )
// #define __msc_mask_datatrandone(n) 	( REG_MSC_IMASK(n) |= MSC_IMASK_DATA_TRAN_DONE )
// #define __msc_unmask_datatrandone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_DATA_TRAN_DONE )
// #define __msc_mask_prgdone(n) 		( REG_MSC_IMASK(n) |= MSC_IMASK_PRG_DONE )
// #define __msc_unmask_prgdone(n) 	( REG_MSC_IMASK(n) &= ~MSC_IMASK_PRG_DONE )

// 
/* m=0,1,2,3,4,5,6,7 */
// #define __msc_set_clkrt(n, m)			\
// 	do {					\
// 		REG_MSC_CLKRT(n) = m;		\
// 	} while(0)

// 
// #define __msc_get_ireg(n) 	        	( REG_MSC_IREG(n) )
// #define __msc_ireg_rd(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_RXFIFO_RD_REQ )
// #define __msc_ireg_wr(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_TXFIFO_WR_REQ )
// #define __msc_ireg_end_cmd_res(n)       	( REG_MSC_IREG(n) & MSC_IREG_END_CMD_RES )
// #define __msc_ireg_data_tran_done(n)     	( REG_MSC_IREG(n) & MSC_IREG_DATA_TRAN_DONE )
// #define __msc_ireg_prg_done(n) 	        	( REG_MSC_IREG(n) & MSC_IREG_PRG_DONE )
// #define __msc_ireg_clear_end_cmd_res(n)         ( REG_MSC_IREG(n) = MSC_IREG_END_CMD_RES )
// #define __msc_ireg_clear_data_tran_done(n)      ( REG_MSC_IREG(n) = MSC_IREG_DATA_TRAN_DONE )
// #define __msc_ireg_clear_prg_done(n)     	( REG_MSC_IREG(n) = MSC_IREG_PRG_DONE )

// 
// #define __msc_get_stat(n) 		( REG_MSC_STAT(n) )
// #define __msc_stat_not_end_cmd_res(n) 	( (REG_MSC_STAT(n) & MSC_STAT_END_CMD_RES) == 0)
// #define __msc_stat_crc_err(n)						\
// 	( REG_MSC_STAT(n) & (MSC_STAT_CRC_RES_ERR | MSC_STAT_CRC_READ_ERROR | MSC_STAT_CRC_WRITE_ERROR_YES) )
// #define __msc_stat_res_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_RES_ERR )
// #define __msc_stat_rd_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_READ_ERROR )
// #define __msc_stat_wr_crc_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_CRC_WRITE_ERROR_YES )
// #define __msc_stat_resto_err(n) 	( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_RES )
// #define __msc_stat_rdto_err(n) 		( REG_MSC_STAT(n) & MSC_STAT_TIME_OUT_READ )

// 
// #define __msc_rd_resfifo(n) 		( REG_MSC_RES(n) )
// #define __msc_rd_rxfifo(n)  		( REG_MSC_RXFIFO(n) )
// #define __msc_wr_txfifo(n, v)  		( REG_MSC_TXFIFO(n) = v )

// 
// #define __msc_reset(n)							\
// 	do { 								\
// 		REG_MSC_STRPCL(n) = MSC_STRPCL_RESET;			\
// 		while (REG_MSC_STAT(n) & MSC_STAT_IS_RESETTING);	\
// 	} while (0)

// 
// #define __msc_start_clk(n)						\
// 	do { 								\
// 		REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_START;	\
// 	} while (0)

// 
// #define __msc_stop_clk(n)						\
// 	do { 								\
// 		REG_MSC_STRPCL(n) = MSC_STRPCL_CLOCK_CONTROL_STOP;	\
// 	} while (0)

// 
const MMC_CLK 19169200
const SD_CLK 24576000

// 
/* msc_clk should little than pclk and little than clk retrieve from card */
// #define __msc_calc_clk_divisor(type,dev_clk,msc_clk,lv)	\
// 	do {						\
// 		unsigned int rate, pclk, i;		\
// 		pclk = dev_clk;				\
// 		rate = type?SD_CLK:MMC_CLK;		\
// 		if (msc_clk && msc_clk < pclk)		\
// 			pclk = msc_clk;			\
// 		i = 0;					\
// 		while (pclk < rate)			\
// 		{					\
// 			i ++;				\
// 			rate >>= 1;			\
// 		}					\
// 		lv = i;					\
// 	} while(0)

// 
/* divide rate to little than or equal to 400kHz */
// #define __msc_calc_slow_clk_divisor(type, lv)		\
// 	do {						\
// 		unsigned int rate, i;			\
// 		rate = (type?SD_CLK:MMC_CLK)/1000/400;	\
// 		i = 0;					\
// 		while (rate > 0)			\
// 		{					\
// 			rate >>= 1;			\
// 			i ++;				\
// 		}					\
// 		lv = i;					\
// 	} while(0)

// 

// 

// 
// #endif /* __MIPS_ASSEMBLER */

// 
// #endif /* __JZ4760BMSC_H__ */

// 
